{"./":{"url":"./","title":"介绍","keywords":"","body":"Introduction Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-01 09:07:57 "},"Html/":{"url":"Html/","title":"HTML","keywords":"","body":"html语义化 背景 在开发过程中，你肯定见过或者自己使用过类似的代码。简单来说就是 一个div写到底。 写的时候挺舒服的，但是当页面结构复杂的时候，命名各有各的习惯。很难直观地看出结构，所以推出了html语义化，让开发人员更规范。 是什么 html语义化就是使用恰当的html标签和class类名让页面结构更清晰。而且方便浏览器识别。 总结就是： 用恰当的标签而不是通篇div 页面结构化 怎么做 举个例子，如下用恰当的标签干恰当的事情，结构化。 article = 独立模块 header = 头部 nav = 导航栏 main = 主要内容 section = 章节 h5 = 标题 p = 段落 figure = 图例 figcaption = 图例的相关说明 aside = 侧边栏 footer = 底部 详细标签查询MDN Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-01 16:20:26 "},"CSS/":{"url":"CSS/","title":"CSS","keywords":"","body":"盒模型 css中每个基本元素的内部结构模型就是盒模型。默认content-box结构如下 共有两种盒模型。构成结构分别是： border-box: 内容区=border+padding+content content-box: 内容区=content Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-01 09:07:57 "},"CSS/Center.html":{"url":"CSS/Center.html","title":"垂直居中","keywords":"","body":"元素居中 水平居中 行内元素text-aligin .wrapper { text-align:center; } 块级元素margin: 0 auto .content { margin:0 auto; } 垂直居中 绝对定位 .wrapper { position:relative; } .content { position: absolute; top:50%; left:50%; transform: translate(-50%,-50%); } flex .wrapper { display: flex; /* 弹性布局 */ align-items: center; /* 垂直居中 */ justify-content: center; /* 水平居中 */ } 3.行内元素单行居中 注意是单行！ .wrapper { height:40px; line-height: 40px; text-align: center; } Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-03 15:43:06 "},"CSS/Flex.html":{"url":"CSS/Flex.html","title":"Flex","keywords":"","body":"Flex flex 控制块级上下文的弹性排列。主要分父级和子级的使用。 父 水平方向jusity-conent 垂直方向align-items 排列方向flex-direction 是否换行flex-wrap 子 排放顺序，小的前面order 收缩比例 flex-shrink 空间扩展比例 flex-grow 自定义在父级的方向 self-flex Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-03 15:55:17 "},"CSS/BFC.html":{"url":"CSS/BFC.html","title":"BFC","keywords":"","body":"BFC 块级格式上下文（Block Formatting Context，BFC）是一种规则，它定义了块级元素的渲染规则。 区域内从左到右，不够排列另起一行 区域内相邻的两个div外边距合并 特性 内部的块级元素垂直摆放。 内部的行内元素水平摆放，放不下另起一行。 相邻的两个div，margin合并。 产生条件 html float元素 position absolute 或fixed 行内块级元素 inline-block 更多看mdn Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-03 15:49:00 "},"CSS/Selector.html":{"url":"CSS/Selector.html","title":"其他","keywords":"","body":"其他 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-01 09:07:57 "},"Js/":{"url":"Js/","title":"JavaScript","keywords":"","body":"数据类型 JavaScript 中每个值都属于某种数据类型。共有7种： String Number Boolean Null Undefined Object Symbol 其中Object 可以细分为3种： Object Array Function 确定类型 typeof typeof 'sss' \"string\" typeof 123 \"number\" typeof true \"boolean\" typeof null \"object\" typeof undefined \"undefined\" typeof function(){} \"function\" var obj = {name:'jim'} undefined typeof obj //js设计规范如此，逻辑错误 \"object\" typeof [1,2,3] \"object\" var sy = new Symbol(1,2,3) typeof Symbol() \"symbol\" 可以发现 typeof 对于 null Object Array 是无法区分的。 instanceof var o = {}; var a = []; o instanceof Array // false a instanceof Array // true Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-03 16:12:34 "},"Js/ArrayUnique.html":{"url":"Js/ArrayUnique.html","title":"数组去重","keywords":"","body":"数组去重 set去重 ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 然后再转数组，就可以去重 var array = [1,2,1,1,\"1\"] function unique(array) { return Array.from(new Set(array)) } unique(array) //[1,2,\"1\"] 或 function unique(array) { return [...new Set(array)] } 遍历 遍历旧数组，如果新数组内没有旧数组元素就添加，最后返回新数组 function unique(arr) { let result = [] arr.map(el => { if(result.indexOf(el) == -1) { result.push(el) } }) return result } var z = [1,1,1,2,2,2,3,3,3,1,2,3] unique(z) //[1,2,3] 数组降重 就是要把多个层级的数组拍平成一个层级 [1, [2], [3, [[4]]]] //[1,2,3,4] 递归 function flatten(arr) { var newArr = [] function _flat(arr) { arr.forEach(value => { if(Array.isArray(value)) { _flat(value) } else { newArr.push(value) } }) } _flat(arr) return newArr } flatten(arr) // [1, 2, 3, 4] Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-04 10:18:55 "},"Js/Function.html":{"url":"Js/Function.html","title":"函数","keywords":"","body":"函数 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-01 09:07:57 "},"Js/Regx.html":{"url":"Js/Regx.html","title":"正则","keywords":"","body":"正则 正则就是计算机语言中一种匹配规则。通过这些规则可以过滤、搜索资源。 创建正则 //构造函数 var reg=new RegExp(']+%>','g'); //字面量 var reg=/]%>/g; 其中，/???/中间代表匹配规则 g 代表修饰符 g: global 全文搜索，不添加的话搜索到第一个结果停止搜索 i: ingore case 忽略大小写，默认大小写敏感 m: multiple lines 多行搜索 不用就忘了的概念 元字符 就是那些特殊符号，回车符。空白符号。常用的： \\r 回车符 \\0 空字符 \\n 换行符 特殊的，平时也不用。用到再百度就OK。 字符类 [] [abcd] //代表匹配abcd中的其中一个， [你要的字符] 取反 ^取反 [^abcd] //代表匹配1个不是a或b或c的字符 范围 -范围 //0-9中的任意一个 var reg1 = /[0123456789]/ //0-9中的任意一个, - 简洁写法 var reg2 = /[0-9]/ //是a-z中的任意一个 var reg3 = /[a-z]/ //大写字母、小写字母、数字中的任意一个 var reg3 = /[a-zA-Z0-9]/ 预定义类 就是预先定义这些代表那些符号，这样写起来就方便。 字符 等价类 含义 . [^\\r\\n] 除了回车符和换行符之外的所有字符 \\d [0-9] 数字字符 \\D [^0-9] 非数字字符 \\s [\\t\\n\\x0B\\f\\r] 空白符 \\S [^\\t\\n\\x0B\\f\\r] 非空白符 \\w [a-zA-Z_0-9] 单词字符，字母、数字下划线 \\W [^a-zA-Z_0-9] 非单词字符 边界 字符 含义 ^ 以xxx开头 $ 以xxx结尾 \\b 单词边界 \\B 非单词边界 var str = 'hello1 world hello2 123456 \\t \\r 哈喽 \\n hello3' // 其中 \\d 数字字符 也就是 0-9 str.match(/hello\\d/g) // [\"hello1\", \"hello2\", \"hello3\"] 匹配hello+数字 str.match(/^hello\\d/g) // [\"hello1\"] 匹配hello开头+数字 str.match(/hello\\d$/g) // [\"hello3\"] 匹配数字结尾 str.match(/\\bhello\\d/g) //[\"hello1\", \"hello2\", \"hello3\"] 匹配单词开头hello+数字 数量词 字符 含义 ? 出现零次或一次（最多出现一次） + 出现一次或多次（至少出现一次） * 出现零次或多次（任意次） {n} 出现n次 {n,m} 出现n到m次 {n,} 至少出现n次 var str = '110' str.match(/\\d{3}/g) //数字出现3此 var str = ‘http://baidu.com’ // . 除了回车符和换行符之外的所有字符 str.match(/https?:\\/\\/.+/) //s出现0次或1次 其他符号出现1次或多次 贪婪模式和非贪婪模式 默认时贪婪模式，也就是尽可能多的匹配，如需要非贪婪模式，只要在量词后面加上?就开启了 \\d表示匹配数字0-9，{3,5}表示3到5次，贪婪模式下5次 '123456789'.match(/\\d{3,5}/g); //[\"12345\", \"6789\"] \\d表示匹配数字0-9，{3,5}表示3到5次，非贪婪模式下3次 '123456789'.match(/\\d{3,5}?/g); //[\"123\", \"456\", \"789\"] // {3,5}? ?非贪婪 或 var str = '叠词可可爱爱，你好恶心心' str.match(/可|爱/g) //[\"可\", \"可\", \"爱\", \"爱\"] 常用正则 判断用户输入的是不是合法的用户名（长度6-20个字符，只能包括字母、数字、下划线）。 var reg = /\\w{6,20}/ 去除字符串两边的空白字符。 function trim(str){ //return str.replace(/^\\s*|\\s*$/g,\"\") return str.replace(/(^\\s*)|(\\s*$)/g, \"\"); //匹配空白开头或空白结尾 * 0-n次 } trim(\" xxx aa bbb \") 总结 正则不用就很容易忘记，也没必要记住。记下来，用到的时候翻一翻，又想起了。 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-16 11:43:05 "},"Js/ajax.html":{"url":"Js/ajax.html","title":"ajax","keywords":"","body":"ajax 是什么? ajax 是 一种技术方案。利用XMLHttpRequest对象，发送http请求和接受http响应。实现页面不刷新情况下与服务器交互数据。 怎么做？ 设置请求地址 监听请求成功事件 发送请求 var request = new XMLHttpRequest() request.open('get','www.baidu.com') request.onreadStateChange = () => { if(request.readState === 4 && requset.status === 200) { console.log(request.responseText) } } request.send() 简化版 var requset = new XMLHttpRequest() request.open('get','www.baicu.com') request.onload(()=> { console.log(request.responseText)}) request.send() axios 添加 npm install axios get请求 axios.get('/user?id=123').then((response)=> { console.log(response) }).catch((error)=>{ console.log(error) })) axios.get('/user', { params: { ID: 12345 } }) .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }); Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-03 17:02:27 "},"Js/Environment.html":{"url":"Js/Environment.html","title":"执行环境及作用域","keywords":"","body":"执行环境及作用域 执行环境（简称为环境）是JavaScript中的一个概念。执行环境定义了变量或函数有权访问的其他数据，决定它们各自的行为。每个执行环境都有一个与之相关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。虽然我们无法访问到该对象，但解析器在处理数据时会在后台使用它。 全局执行环境是最外围的一个执行环境。在浏览器中，就是window对象。 每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境被推入一个环境栈中。函数执行后，栈将其环境弹出，把控制权返回给之前的执行环境。 作用域链 当代码咋一个环境中执行，会创建·变量对象的一个作用域链。它的作用保证环境的所有变量和函数的有序访问。也就是全局环境执行，执行到函数时，进入下一层环境继续执行。如内部有函数，继续下层执行。每次函数执行后，返回之前的环境中。 var color = 'green' function changeColor() { if(color === 'green') { color = 'red' } else { color = 'blue' } } changeColor() changeColor有的作用域链有两个对象，全局环境和它本身的环境。可以在函数内部访问到变量color，就是因为可以在这个作用域链中找到它。 总结 执行环境保存了它的变量和函数。 函数有它自己的执行环境。 函数执行的时候，先从内部环境找变量 如果找不到，通过作用域链在上层环境中寻找。 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-04 09:39:30 "},"Js/Closure.html":{"url":"Js/Closure.html","title":"闭包","keywords":"","body":"闭包 闭包是什么？ 闭包是指有权访问里一个函数作用域链中的变量的函数。-- JavaScript高级程序设计（红皮书） 也就是如果在函数里面可以访问外面的变量，那么这个函数+这些变量 = 闭包。 看看例子： function A(){ var a = 1 function B(){ console.log(a) } return B } var fn = A() fn() //1 fn()就是调用函数A()，函数A()执行了函数B。函数B执行的时候通过作用域链找到变量a。那么函数B和它能访问到的变量a之和就是闭包。 需要注意的是。闭包所保存的是整个变量对象。也就是 {a : 1} 如果a执行过程中发生改变，闭包中的a也改变。 function A(){ var a = 1 function B(){ console.log(a) } a = 3 // 修改 a 值 return B } var fn = A() fn() //3 总结 那闭包的特点呢？ 能函数维持住变量 但是不能维持变量的值 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-04 10:21:12 "},"Js/This.html":{"url":"Js/This.html","title":"this","keywords":"","body":"this this的确定 关于this在红皮书中或MDN中没有明确的定义。 在绝大多数情况下，函数的调用方式决定了this的值。this不能在执行期间被赋值，并且在每次函数被调用时this的值也可能会不同。ES5引入了bind方法来设置函数的this值，而不用考虑函数如何被调用的，ES2015 引入了支持this词法解析的箭头函数（它在闭合的执行环境内设置this的值）。 虽然没有明确定义，但总归有规律可循。这里引用this 的值到底是什么？一次说清楚的方法。因为这样很好记忆。 this 是什么 this就是 call的第一个call参数.需要在它被调用的时候传入的参数才能确定。 显式this 明确给this赋值 fn.call(asThis,1,2) fn.bind(asThis,1,2)() obj.method.call(obj,'hi') 隐式this 没有明确给this赋值的情况下，通过补上call的情况来判断this到底是什么？ fn(1,2) //fn.call(undefined,1,2) 需要看声明fn的环境下，this是什么，全局的话是window obj.method('hi') //obj.method.call(obj,'hi') array[0]('hi') array.[0].call(array,'hi') 测试 button.onclick = function(e){ console.log(this) } // this 是什么？ this 未确定，因为还没被调用。如果用户点击，那么this传入button 如果通过函数调用，如下： var f = button.onclick f() // f.call(undefined) 声明环境全局所以this是window 所以明确this 的步骤 调用没 明确this的pass，不明确的通过call补全去判断 this 测试难度+1 let length = 10 function fn(){console.log(this.length)} let obj = { length: 5, method(fn) { fn() arguments[0]() } } obj.method(fn,1) 分情况讨论。fn fn() // fn.call(undefined) 声明时全局 this.length 等于 window.length length是window的自由属性，所以let length = 10 不会覆盖 window.length 默认window.length == i 返回当前窗口中包含的框架数量(框架包括frame和iframe两种元素). arguments[0]()的情况 arguments[0]() // arguments.0.call(arguments) this 等于arguments // arguments输入时两个参数，所以 arguments.length 等于 2 总结 this 要在调用时才能确定 有传this 不用讨论 没传this 通过补上call确定 fn(1,2) 等价于fn.call(undefined,1,2)需要看声明fn的环境下，this是什么，全局的话是window obj.method('hi') 等价于obj.method.call(obj,'hi') array[0]('hi') 等价于array.[0].call(array,'hi') Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-16 16:11:41 "},"Js/Throttled.html":{"url":"Js/Throttled.html","title":"函数节流和防抖","keywords":"","body":"函数节流和防抖 节流 在游戏中，技能都有CD机制，也就是cd中不能使用技能。 这种机制也就是节流： function throttle(fn,delay){ let canUse = true return function () { if(!canUse) return canUse = false setTimeout(() => { fn.apply(this, arguments) canUse = true },delay) } } 节流的好处，就是防止用户无效输入给服务端。 常见于底部滚动加载。 防抖 防抖呢，就是触发事件时生成定时器等待，如果定时期间再次触发事件，则重新生成定时器继续等待。如果定时器过去则调用函数。像外卖小哥接了外卖，等待4分种有没有新单子，有就继续接单。没有就派送外卖。 function debounce(fn, delay) { let timerId = null return function() { if(timerId) {window.clearTimeout(timerId)} timerId = setTimeout(() => { fn.apply(this,arguments) timerId = null },delay) } } 防抖常见于用户输入搜索限制。 总结 节流就是CD中，只执行一次函数，防止用户多余输入。 防抖就是外卖小哥送外卖，等待接单，有则继续接单继续等，没有就派单。 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-16 16:39:02 "},"Js/Extend.html":{"url":"Js/Extend.html","title":"继承","keywords":"","body":"继承 继承是指一个对象直接使用另一对象的属性和方法。 在calss语法之前。只能自己实现。方法很多。 所以继承，做了两件事： 得到一个类的属性 得到一个类的方法 属性获取 通过call/apply 绑定属性 function Animal(color) { this.color = color } Animal.prototype.move = function () {} function Dog(color,name) { Animal.call(this,color) Animal.apply(this,arguments)//多个属性时用apply this.name = name } 方法获取 Dog.prototype = Object.create(Animal.prototype) //Object.create(Animal.prototype) 创建一个空对象 空对象.__proto__ 指向Animal //Dog.prototype 通过该空对象获取了animal的方法 注意！Dog.prototype的方法必须在Object.create()之后不然会被覆盖。 然后把constructor指向自己的ok了。 Dog.prototype.constructor = Dog 总结 完整版如下 fuction Animal(color) { this.color = color } Animal.prototype.move = function() {} function Dog(color,name) { //获取属性 Animal.call(this,color) //Animal.apply(this,arguments)多个属性用apply this.name = name } //获取方法 Dog.prototype = Object.create(Animal.prototype) Dog.prototype.constructor = Dog class es6推出class之后就方便了，跟java类似。 class Animal{ constructor(color) { this.color = color } move(){} } class Dog extends Animal { constructor(color,name){ super(color) this.name = name } say() {} } 总结 继承就是要一个类的属性和方法。es6推出class后，使用它继承就可以了。 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-16 16:08:18 "},"Js/Prototype.html":{"url":"Js/Prototype.html","title":"原型和原型链","keywords":"","body":"原型和原型链 原型表示一个类/对象的继承关系。 function Person(name,age) { this.name = 'jim' this.age = age } Person.prototype.sayName = function() { console.log(this.name) } var p1 = new Person() p1.sayName() 通过函数定义了类 Person, 类（函数）自动获取熟悉prototype 每个类的实例如p1都会有个内部属性__proto__ 原型链 原型链就是对象上的__proto__，通过原型链可以获得基础方法。 var str = [1,2,3,4] str.push() .push() 方法就是通过 str.__proto__获取的。通过constructor可以看出它的原型是Array。 .toString则是通过Array.__proto__找到的。 总结 实例通过__proto__获取类上的方法。 可以通过__proto__.constructor可以知道实例的父类 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-16 16:21:51 "},"Js/Es6.html":{"url":"Js/Es6.html","title":"es6","keywords":"","body":"es6 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-16 17:27:48 "},"Dom/":{"url":"Dom/","title":"Dom","keywords":"","body":"Dom Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-01 09:07:57 "},"EventBubbling.html":{"url":"EventBubbling.html","title":"事件冒泡","keywords":"","body":"事件冒泡 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-01 09:07:57 "},"Http/":{"url":"Http/","title":"Http","keywords":"","body":"Http Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-01 09:07:57 "},"Http/Message.html":{"url":"Http/Message.html","title":"Http报文","keywords":"","body":"Http报文 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-01 09:07:57 "},"Http/StatusCode.html":{"url":"Http/StatusCode.html","title":"状态码","keywords":"","body":"状态码 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-01 09:07:57 "},"Http/Cache.html":{"url":"Http/Cache.html","title":"缓存","keywords":"","body":"缓存 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-01 09:07:57 "},"Network/":{"url":"Network/","title":"网络安全","keywords":"","body":"网络安全 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-01 09:07:57 "},"Network/CrossDomain.html":{"url":"Network/CrossDomain.html","title":"同源策略&&跨域","keywords":"","body":"同源策略&&跨域 背景 浏览器出于安全方面的考虑，只允许与本域下的接口交互。不同源的客户端脚本在没有明确授权的情况下，不能读写对方的资源。 本域指的是？ 同协议：如都是http或者https 同域名：如都是http://baidu.com/a和http://baidu.com/b 同端口：如都是80端口 举个例子 http://baidu.com/a.js 和 http://baidu.com/b.php 他们是在同源下所以可以正常访问。 不同源的例子： http://baidu.com/main.js 和 https://baidu.com/a.php (协议不同) http://baidu.com/main.js 和 http://bbs.baidu.com/a.php (域名不同，域名必须完全相同才可以) http://baidu.com/main.js 和 http://baidu.com:8080/a.php (端口不同,第一个是80) 但实际使用中，我们有访问不同源下的资源的需求。所以有了下面的几种方法 跨域的方法 JSONP script标签能访问其他域名资源。利用这个特性也能跨域。 访问时提交回调。 当服务器接受到callback回调时，返回你想要的参数。最后在页面接受参数 function showData(ret){ console.log(ret); } 总结流程： 通过script标签在页面提前声明个函数，函数名通过接口传参的方式传给后台 后台解析到函数名后把数据包括在函数名，发送给前端。 缺点 麻烦，每个函数都要处理 前后端都要处理 CORS 跨域资源共享（CORS）是一种白名单机制，通过额外的http header 告诉浏览器，哪些跨域资源可以用。具体需要在后台发送http请求时配置。 res.setHeader('Access-Control-Allow-Origin','http://localhost:8080') //res.setHeader('Access-Control-Allow-Origin','*') 对于需要跨域的域名，放开权限即可。 总结 跨域是为了保护服务器的安全，但设计者也留了通道给服务器访问不同域的资源。 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-16 10:45:41 "},"Webpack/":{"url":"Webpack/","title":"Webpack","keywords":"","body":"Webpack Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-01 09:07:57 "},"Vue/":{"url":"Vue/","title":"Vue","keywords":"","body":"响应式原理 Vue 使用 Object.defineProperty 把data中属性转换为 getter/setter var data = {} undefined var _name = 'jim' //通过Object.defineProperty做了个映射的关系 Object.defineProperty(data,'name',{ get() {return _name}, set(value) { _name = value console.log('更新ui') } }) data.name // jim _name // jim data.name = 'coco' //调用set，这里可以更新ui //更新ui _name // coco 缺点 新增属性没法触发set，也就没有响应式刷新 data.color = 'red' //新增属性没法触发set，也就没有响应式刷新 \"red\" vue提供的解决方法 对于已经创建的实例，Vue 不允许动态添加根级别的响应式属性。但是，可以使用 Vue.set(object, propertyName, value) 方法向嵌套对象添加响应式属性。 Vue.set(vm.someObject, 'b', 2) Vue3.0新方法Proxy Proxy 对象用于定义基本操作的自定义行为（如属性查找、赋值、枚举、函数调用等）。 es6中新增Proxy，使用Proxy代理对象。Proxy能监听到新增属性。 var data = {name:\"jim\"} var dataProxy = new Proxy(data,{ get(target,key) { if(key === 'name') { return data.name } }, set(target,key,value) { data[key] = value console.log(\"更新UI\") } }) dataProxy.name //\"jim\" dataProxy.name = 'coco' //更新UI //新增的color也能监听到 dataProxy.color ='red' // 更新UI 总结 Object.defineProperty把对象转换为getter/setter,当setter更新数据时更新UI 但是它无法监听到新增的属性 Vue可以使用Vue.set(object, propertyName, value) 来新增属性，这样也能响应式更新 Proxy为更好的解决方案 参考 Object.defineProperty Proxy MDN Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-16 23:09:10 "},"Vue/Component.html":{"url":"Vue/Component.html","title":"组件通信","keywords":"","body":"组件通信 父子组件 父向子 ，通过props传递数据就可以。 子向父，由于vue是单向数据流。这个过程麻烦点。 父组件自定义事件监听儿子传参事件 子组件通过Vue.emit()触发自定义事件change并传递参数。 methods: { emitDataToPapa() { this.$emit('change','data') } } 在父组件处理儿子传参事件 methods: { handleTotal(sonMsg) { console.log(sonMsg) } } 非父子组件通信 使用一个空的Vue实例作为中央事件总线： var bus = new Vue() 在组件A创建监听事件 bus.$on('eventName',function(data){ //触发后的数据操作 }) 触发组件B中的事件，传递参数 bus.$emit('eventName','dataToA') Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-16 18:04:32 "},"Vue/VueRouter.html":{"url":"Vue/VueRouter.html","title":"VueRouter","keywords":"","body":"VueRouter 就是Vue推出的一个官方路由管理器。 基础使用 //跳转 Home | About //渲染出口 //vue.$route 获取路由参数 vue.$route.query.id //vue.$router 调用路由方法 vue.$router.go() vue.$touter.push() 路由守卫 在路由跳转前后对路由进行操作。 例如将 异常url转移到404页面。 权限限制，当前用户不能访问的跳转404。 打开新页面。 这里只拿beforeEach举例 const router = new VueRouter({.}) router.beforeEach((to,from,next) => { //例如权限限制 }) 目前用到的栗子 router.beforeEach((to, from, next) => { /* 公共路由 */ let commonArray = ['/login', '/home',,'/404']; //登陆时将用户可访问路由添加在本地localStorage，路由跳转前权限限制。 let allRoute = commonArray.concat(JSON.parse(localStorage.getItem('routeArr'))); if (allRoute.contains(to.path)) {/* 是否是公共路由 */ if (to.path == '/onemap') { //特殊页面，特殊处理 window.open('#/onemap', '_blank'); } else { next() } } else { next('/404'); } }) 路由懒加载 可以将异步组件定义为返回一个 Promise 的工厂函数 。 一般vue-cli生成的模板里就有得参考。 const router = new VueRouter({ routes: [ { path: '/foo', component: () => import('./foo.vue') } ] }) 参考 vueRouter官网 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-16 21:58:11 "},"Vue/VueX.html":{"url":"Vue/VueX.html","title":"VueX","keywords":"","body":"# Vuex 是什么？ Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。 也就是官方的状态管理中心。 什么时候要用Vuex？ 中大型应用 需要管理状态 状态太多，eventBus不能满足 概念和怎么用？ State 就是存放基础状态的地方 声明 state 的参数 state: { infos: { age: 18, sex: '女性', firstName: '张', lastName: '三' } }, 在组件中获取state this.$store.state.students Getter 相当于计算属性，对state的过滤或条件限制 getters: { totalName: state => { return state.infos.firstName + state.infos.lastName } }, 在组件中获取Getter computed: { totalName() { return this.$store.getters.totalName } }, Mutation 对state的数据进行操作修改。 mutations: { addAge(state) { state.infos.age++ } }, 在组件中只需调用 Mutation 事件 addAge() { this.$store.commit('addAge') }, 但Mutation 只限于同步函数。异步操作须在Action中使用 Action 对mutation 进行操作m.接受的参数是context，用来出发mutaion actions: { addAgeAction(context) { // context.commit('addAge') //异常操作才使用action，如请求接口后 setTimeout(() => { context.commit('addAge') }, 1000); } }, 调用 Action addAgeAction() { this.$store.dispatch('addAgeAction') } Module Module就是模块，但状态太多的时候，区分不同模块。 const moduleA = { state: { ... }, mutations: { ... }, actions: { ... }, getters: { ... } } const moduleB = { state: { ... }, mutations: { ... }, actions: { ... } } const store = new Vuex.Store({ modules: { a: moduleA, b: moduleB } }) Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-16 22:07:41 "},"Vue/OtherImportance.html":{"url":"Vue/OtherImportance.html","title":"其他常见问题","keywords":"","body":"其他常见问题 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-01 09:07:57 "},"Advanced/":{"url":"Advanced/","title":"前端进阶","keywords":"","body":" 闭包 如果在函数里面可以访问外面的变量，那么这个函数+这些变量 = 闭包 闭包+时间 请问下面打印除什么？ for(var i=0;i console.log(i) ) } 6个6。因为六个函数公用一个 i 如果需要打印0，1，2，3，4，5 for(let i= 0;i console.log(i) ) } 总结 闭包的作用： 生成局部变量。 this 的确定 let length = 10 function fn(){ console.log(this.length) } //fn.call(undefined, this.length) let obj = { length: 5, method(fn){ fn.call(obj,arguments[0]()) fn()arguments[0]() } } obj.method(fn, 1)// 输出什么 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-01 09:07:57 "},"Advanced/EventHub.html":{"url":"Advanced/EventHub.html","title":"手写EventHub","keywords":"","body":"手写EventHub eventHub 是什么？ eventHub 是事件中转站。它提供功能： 提交函数到eventHub中对应的事件 触发eventHub 中对应事件的函数 取消eventHub中对应事件的函数 class EventHub { constructor () { this.cache = {} } } on（事件名，回调函数） on(eventName,fn) { this.cache[eventName] = this.cache[eventName] || [] this.cache[eventName].push(fn) } emit(事件名，提交参数) emit(eventName,args) { (this.cache[eventName] || []).forEach(fn => { fn(args) }) } off(事件名，取消函数名) off(eventName,fn) { let index = this.cache[eventName].indexOf(fn) this.cache[eventName].splice(index,1) } 总结 合并之后，代码如下。 class EventHub { constructor () { this.cache = {} } on (eventName, fn) { this.cache[eventName] = this.cache[eventName] || [] this.cache[eventName].push(fn) } emit (eventName, args) { (this.cache[eventName] || []).forEach( fn => { fn(args) }); } off (eventName, fn) { let index = this.cache[eventName].indexOf(fn) this.cache[eventName].splice(index, 1) } } module.exports = EventHub 缺点 eventHub在数据少量的情况下，表现不错。但在多人合作，会出现多处地方提交相同事件等问题。如果需要统一管理，如vue中可以换成Vuex。 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-05 09:34:26 "},"Advanced/DeepClone.html":{"url":"Advanced/DeepClone.html","title":"手写深拷贝","keywords":"","body":"手写深拷贝 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-01 09:07:57 "},"Advanced/Bind.html":{"url":"Advanced/Bind.html","title":"手写bind","keywords":"","body":"手写bind Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-01 09:07:57 "},"Advanced/Promise.html":{"url":"Advanced/Promise.html","title":"手写Promise","keywords":"","body":"手写Promise Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-01 09:07:57 "},"Advanced/Async.html":{"url":"Advanced/Async.html","title":"async await全解","keywords":"","body":"async await全解 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-01 09:07:57 "},"Advanced/EventLoop.html":{"url":"Advanced/EventLoop.html","title":"EventLoop事件循环","keywords":"","body":"EventLoop事件循环 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-01 09:07:57 "},"Advanced/Extend.html":{"url":"Advanced/Extend.html","title":"继承与组合","keywords":"","body":"继承与组合 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-01 09:07:57 "},"MobileDevice/":{"url":"MobileDevice/","title":"移动端","keywords":"","body":"移动端适配 背景（why） 一些概念（what） 怎么做？（how） Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-16 10:12:02 "},"MobileDevice/onePx.html":{"url":"MobileDevice/onePx.html","title":"1px问题","keywords":"","body":"1px问题 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-16 10:14:49 "},"Wx/":{"url":"Wx/","title":"小程序","keywords":"","body":"小程序 我时学了vue之后再学小程序的，感觉小程序跟vue差不多。所以这里只记录我常犯的错误或重要内容。 小程序的文件结构 WXML 页面 WXSS 样式设置 js 逻辑处理 json 标题等设置 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-16 23:27:42 "},"Interview/":{"url":"Interview/","title":"面试","keywords":"","body":"面试 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-01 09:07:57 "},"Other/":{"url":"Other/","title":"其他","keywords":"","body":"其他 gitbook 常用命令 gitbook serve 启动服务 gitbook init 根据SUMMARY.md的结构初始化目录 gitbook build 生成网页 提交 提交源码 git add . git commit -m '提交说明' git push git@github.com:wheadplus/gitbook.git 部署gh-pages cd _book git add . git commit -m '提交说明' git push git@github.com:wheadplus/gitbook.git gh-pages Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-16 23:29:36 "},"Other/git.html":{"url":"Other/git.html","title":"git","keywords":"","body":"git Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-01 09:07:57 "},"Other.html":{"url":"Other.html","title":"翻墙","keywords":"","body":"翻墙 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-01 09:07:57 "}}